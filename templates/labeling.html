{% extends "base.html" %}

{% block title %}{{ title }}{% endblock %}

{% block navigation %}
<!-- Hide navigation for labeling interface -->
{% endblock %}

{% block footer %}
<!-- Hide footer for labeling interface -->
{% endblock %}

{% block content %}
<div class="h-screen flex flex-col">
    <!-- Header -->
    <div class="bg-gray-800 shadow-sm border-b border-gray-700 px-6 py-4">
        <div class="flex items-center justify-between">
            <div>
                <div class="flex items-center space-x-2">
                    <h1 id="project-name-display" class="text-2xl font-bold text-white cursor-pointer hover:text-blue-300 transition-colors"
                        data-project-id="{{ project.id }}">{{ project.name }}</h1>
                    <button id="edit-project-name" class="text-gray-400 hover:text-blue-400 transition-colors" title="Edit project name">
                        <i class="fas fa-edit text-sm"></i>
                    </button>
                </div>
                <input id="project-name-input" type="text" value="{{ project.name }}"
                       class="text-2xl font-bold text-white bg-transparent border-b-2 border-blue-500 focus:outline-none focus:border-blue-400 hidden"
                       data-project-id="{{ project.id }}">
            </div>
            <div class="flex items-center space-x-4">
                <div id="username-display" class="text-sm text-gray-300 hidden">
                    <i class="fas fa-user mr-2"></i><span id="username-text"></span>
                </div>
                <div id="username-input-container" class="flex items-center space-x-2">
                    <input id="username-input" type="text" placeholder="Enter your name" required
                           class="px-3 py-1 rounded bg-gray-700 text-white text-sm border border-gray-600 focus:border-blue-500 focus:outline-none"
                           style="width: 200px;">
                    <button id="save-username" class="px-3 py-1 rounded bg-blue-600 text-white text-sm hover:bg-blue-700 transition-colors">
                        <i class="fas fa-check mr-1"></i>Save
                    </button>
                </div>
                <div class="text-sm text-gray-400">
                    <span id="current-image">1</span> of <span id="total-images">{{ images|length }}</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Context Menu for Annotations -->
    <div id="annotation-context-menu" class="fixed bg-gray-800 border border-gray-600 rounded-lg shadow-lg z-50 hidden" style="min-width: 200px;">
        <div class="py-1">
            <button id="edit-annotation" class="w-full px-4 py-2 text-left text-sm text-blue-400 hover:bg-gray-700 flex items-center">
                <i class="fas fa-edit mr-2"></i>Edit Category
            </button>
            <button id="delete-annotation" class="w-full px-4 py-2 text-left text-sm text-red-400 hover:bg-gray-700 flex items-center">
                <i class="fas fa-trash mr-2"></i>Delete Annotation
            </button>
        </div>
    </div>

    <div class="flex-1 flex">
        <!-- Sidebar -->
        <div class="w-80 bg-gray-800 border-r border-gray-700 flex flex-col">
            <!-- Label Categories -->
            <div class="p-4 border-b border-gray-700">
                <h3 class="text-lg font-semibold text-white mb-3">Label Categories</h3>
                <div class="space-y-2">
                    {% for category in label_categories %}
                    <div class="label-category flex items-center p-2 rounded-lg cursor-pointer hover:bg-gray-700 transition-colors"
                         data-category-id="{{ category.id }}"
                         data-color="{{ category.color }}">
                        <div class="w-4 h-4 rounded-full mr-3" style="background-color: {{ category.color }}"></div>
                        <span class="text-sm font-medium text-gray-200">{{ category.name }}</span>
                    </div>
                    {% endfor %}
                </div>
                <button id="add-category" class="mt-3 w-full text-sm text-blue-400 hover:text-blue-300 font-medium">
                    <i class="fas fa-plus mr-1"></i>Add Category
                </button>
            </div>

            <!-- Image Upload -->
            <div class="p-4 border-b border-gray-700">
                <h3 class="text-lg font-semibold text-white mb-3">Upload Images</h3>
                <div class="space-y-3">
                    <div class="border-2 border-dashed border-gray-600 rounded-lg p-4 text-center hover:border-blue-400 transition-colors">
                        <input type="file" id="image-upload" multiple accept="image/*,.tiff,.tif" class="hidden">
                        <input type="file" id="yolo-classes-upload" accept=".txt" class="hidden">
                        <label for="image-upload" class="cursor-pointer">
                            <i class="fas fa-cloud-upload-alt text-3xl text-gray-400 mb-2"></i>
                            <p class="text-sm text-gray-300">Click to upload images</p>
                            <p class="text-xs text-gray-500">PNG, JPG, JPEG, GIF, TIFF supported</p>
                        </label>
                    </div>
                    <button id="upload-images" class="w-full bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        <i class="fas fa-upload mr-2"></i>Upload Selected Images
                    </button>
                </div>
            </div>

            <!-- Image Thumbnails -->
            <div class="flex-1 p-4 overflow-y-auto">
                <div class="flex items-center justify-between mb-3">
                    <h3 class="text-lg font-semibold text-white">Images</h3>
                    <span class="text-sm text-gray-400" id="image-count">{{ images|length }} images</span>
                </div>
                <div class="grid grid-cols-2 gap-2" id="image-grid">
                    {% for image in images %}
                    <div class="image-thumbnail cursor-pointer border-2 border-transparent hover:border-blue-500 rounded-lg overflow-hidden transition-colors relative group"
                         data-image-id="{{ image.id }}">
                        <img src="/{{ image.thumbnail_path }}"
                             alt="{{ image.original_filename }}"
                             class="w-full h-20 object-cover">
                        <div class="p-1 text-xs text-gray-300 truncate">{{ image.original_filename }}</div>
                        <!-- Delete button for thumbnail -->
                        <button class="thumbnail-delete-btn absolute top-1 right-1 w-6 h-6 bg-red-600 text-white rounded-full opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex items-center justify-center text-xs hover:bg-red-700"
                                data-image-id="{{ image.id }}"
                                data-image-name="{{ image.original_filename }}"
                                title="Delete image">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    {% endfor %}
                </div>
            </div>
        </div>

        <!-- Main Canvas Area -->
        <div class="flex-1 flex flex-col">
            <!-- Toolbar -->
            <div class="bg-gray-800 border-b border-gray-700 px-4 py-2">
                <div class="flex items-center space-x-4">
                    <div class="flex items-center space-x-2">
                        <button id="select-tool" class="tool-btn active px-3 py-1 rounded text-sm font-medium bg-blue-600 text-white">
                            <i class="fas fa-mouse-pointer mr-1"></i>Select
                        </button>
                        <button id="bbox-tool" class="tool-btn px-3 py-1 rounded text-sm font-medium text-gray-300 hover:bg-gray-700">
                            <i class="fas fa-square mr-1"></i>Bounding Box
                        </button>
                        <button id="polygon-tool" class="tool-btn px-3 py-1 rounded text-sm font-medium text-gray-300 hover:bg-gray-700">
                            <i class="fas fa-draw-polygon mr-1"></i>Polygon
                        </button>
                        <button id="point-tool" class="tool-btn px-3 py-1 rounded text-sm font-medium text-gray-300 hover:bg-gray-700">
                            <i class="fas fa-circle mr-1"></i>Point
                        </button>
                        <div class="w-px h-6 bg-gray-600"></div>
                        <button id="pan-tool" class="tool-btn px-3 py-1 rounded text-sm font-medium text-gray-300 hover:bg-gray-700" title="Pan tool (Hold and drag to pan)">
                            <i class="fas fa-hand-paper mr-1"></i>Pan
                        </button>
                        <button id="clear-tool" class="tool-btn px-3 py-1 rounded text-sm font-medium text-red-400 hover:bg-red-900 hover:text-red-300">
                            <i class="fas fa-trash mr-1"></i>Clear All
                        </button>
                        <div class="w-px h-6 bg-gray-600"></div>
                        <button id="export-yolo" class="tool-btn px-3 py-1 rounded text-sm font-medium text-green-400 hover:bg-green-900 hover:text-green-300" title="Export annotations to YOLO format">
                            <i class="fas fa-download mr-1"></i>Export YOLO
                        </button>
                        <button id="import-yolo-classes" class="tool-btn px-3 py-1 rounded text-sm font-medium text-blue-400 hover:bg-blue-900 hover:text-blue-300" title="Import YOLO classes from classes.txt">
                            <i class="fas fa-upload mr-1"></i>Import Classes
                        </button>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button id="zoom-in" class="px-2 py-1 rounded text-sm text-gray-300 hover:bg-gray-700">
                            <i class="fas fa-search-plus"></i>
                        </button>
                        <button id="zoom-out" class="px-2 py-1 rounded text-sm text-gray-300 hover:bg-gray-700">
                            <i class="fas fa-search-minus"></i>
                        </button>
                        <button id="fit-to-screen" class="px-2 py-1 rounded text-sm text-gray-300 hover:bg-gray-700">
                            <i class="fas fa-expand-arrows-alt"></i>
                        </button>
                        <div class="w-px h-6 bg-gray-600"></div>
                        <button id="close-image" class="px-3 py-1 rounded text-sm text-gray-300 hover:bg-red-600 hover:text-white transition-colors opacity-50 cursor-not-allowed" disabled>
                            <i class="fas fa-times mr-1"></i>Close Image
                        </button>
                        <button id="delete-image" class="px-3 py-1 rounded text-sm text-gray-300 hover:bg-red-700 hover:text-white transition-colors opacity-50 cursor-not-allowed" disabled>
                            <i class="fas fa-trash mr-1"></i>Delete Image
                        </button>
                    </div>
                </div>
            </div>

            <!-- Image Canvas -->
            <div class="flex-1 relative overflow-hidden bg-gray-900">
                <div id="canvas-container" class="absolute inset-0">
                    <div id="image-container" class="relative">
                        <img id="main-image"
                             src=""
                             alt="Image to label"
                             class="hidden">
                        <canvas id="annotation-canvas"
                                class="absolute inset-0 cursor-crosshair"></canvas>
                        <!-- No image placeholder -->
                        <div id="no-image-placeholder" class="flex flex-col items-center justify-center h-64 text-gray-500">
                            <i class="fas fa-image text-6xl mb-4"></i>
                            <p class="text-lg font-medium">No image selected</p>
                            <p class="text-sm">Upload images to get started with labeling</p>
                        </div>
                    </div>
                </div>

                <!-- Loading overlay -->
                <div id="loading-overlay" class="absolute inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center hidden">
                    <div class="text-center">
                        <div class="spinner mx-auto mb-4"></div>
                        <p class="text-gray-300">Loading image...</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Add Category Modal -->
<div id="add-category-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center z-50">
    <div class="bg-gray-800 rounded-lg p-6 w-96 border border-gray-700">
        <h3 class="text-lg font-semibold text-white mb-4">Add Label Category</h3>
        <form id="category-form">
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-300 mb-2">Category Name</label>
                <input type="text" id="category-name" required
                       class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-blue-500 focus:border-blue-500">
            </div>
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-300 mb-2">Color</label>
                <div class="flex items-center space-x-2">
                    <input type="color" id="category-color" value="#3B82F6"
                           class="w-12 h-8 border border-gray-600 rounded bg-gray-700">
                    <input type="text" id="category-color-text" value="#3B82F6"
                           class="flex-1 px-3 py-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                </div>
            </div>
            <div class="flex justify-end space-x-3">
                <button type="button" id="cancel-category"
                        class="px-4 py-2 text-sm font-medium text-gray-300 bg-gray-700 rounded-md hover:bg-gray-600">
                    Cancel
                </button>
                <button type="submit"
                        class="px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-md hover:bg-blue-700">
                    Add Category
                </button>
            </div>
        </form>
    </div>
</div>

<!-- Delete Image Confirmation Modal -->
<div id="delete-image-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center z-50">
    <div class="bg-gray-800 rounded-lg p-6 w-96 border border-gray-700">
        <h3 class="text-lg font-semibold text-white mb-4">Delete Image</h3>
        <p class="text-gray-300 mb-6">Are you sure you want to delete this image? This action cannot be undone and will also delete all associated annotations.</p>
        <div class="flex justify-end space-x-3">
            <button type="button" id="cancel-delete"
                    class="px-4 py-2 text-sm font-medium text-gray-300 bg-gray-700 rounded-md hover:bg-gray-600">
                Cancel
            </button>
            <button type="button" id="confirm-delete"
                    class="px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700">
                <i class="fas fa-trash mr-1"></i>Delete Image
            </button>
        </div>
    </div>
</div>

<!-- Thumbnail Delete Confirmation Modal -->
<div id="thumbnail-delete-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center z-50">
    <div class="bg-gray-800 rounded-lg p-6 w-96 border border-gray-700">
        <h3 class="text-lg font-semibold text-white mb-4">Delete Image</h3>
        <p class="text-gray-300 mb-2">Are you sure you want to delete this image?</p>
        <p class="text-sm text-gray-400 mb-6" id="thumbnail-delete-image-name"></p>
        <p class="text-gray-300 mb-6">This action cannot be undone and will also delete all associated annotations.</p>
        <div class="flex justify-end space-x-3">
            <button type="button" id="cancel-thumbnail-delete"
                    class="px-4 py-2 text-sm font-medium text-gray-300 bg-gray-700 rounded-md hover:bg-gray-600">
                Cancel
            </button>
            <button type="button" id="confirm-thumbnail-delete"
                    class="px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-md hover:bg-red-700">
                <i class="fas fa-trash mr-1"></i>Delete Image
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// Page setup (scrolling is enabled)
document.addEventListener('DOMContentLoaded', function() {
    // Any page initialization needed
});

// Data labeling interface JavaScript
let currentImageIndex = 0;
let currentTool = 'select';
let selectedCategory = null;
let annotations = [];
let isDrawing = false;
let startX, startY;
let selectedAnnotations = []; // Array of selected annotations for multi-select
let polygonPoints = []; // For polygon drawing
let isDrawingPolygon = false;
let isDraggingAnnotations = false; // Track if we're dragging selected annotations
let dragStartX = 0;
let dragStartY = 0;
let annotationOriginalPositions = []; // Store original positions when drag starts
let lastContextMenuX = 0; // Store last right-click position for context menu
let lastContextMenuY = 0;

// Zoom and pan variables
let zoomLevel = 1;
let panX = 0;
let panY = 0;
let isPanning = false;
let lastPanX = 0;
let lastPanY = 0;

// Image dimensions for bounds checking
let imageWidth = 0;
let imageHeight = 0;

// Helper function to clamp coordinates within image bounds
function clampToImageBounds(x, y) {
    return {
        x: Math.max(0, Math.min(x, imageWidth - 1)),
        y: Math.max(0, Math.min(y, imageHeight - 1))
    };
}

const images = {{ images | tojson }};
const labelCategories = {{ label_categories | tojson }};

// Initialize the interface
document.addEventListener('DOMContentLoaded', function() {
    if (images.length > 0) {
        loadImage(0);
    } else {
        showNoImagePlaceholder();
    }

    setupEventListeners();
});

function setupEventListeners() {
    // Tool selection
        document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            // Handle clear button separately
            if (this.id === 'clear-tool') {
                clearAllAnnotations();
                return;
            }
            // Handle export button separately
            if (this.id === 'export-yolo') {
                exportToYOLO();
                return;
            }
            // Handle import classes button separately
            if (this.id === 'import-yolo-classes') {
                importYOLOClasses();
                return;
            }

            document.querySelectorAll('.tool-btn').forEach(b => {
                b.classList.remove('active', 'bg-blue-600', 'text-white', 'bg-blue-100', 'text-blue-700');
                b.classList.add('text-gray-300', 'hover:bg-gray-700');
            });
            this.classList.add('active', 'bg-blue-600', 'text-white');
            this.classList.remove('text-gray-300', 'hover:bg-gray-700');
            currentTool = this.id.replace('-tool', '');

            // Update cursor based on tool
            const canvas = document.getElementById('annotation-canvas');
            if (currentTool === 'pan') {
                canvas.style.cursor = 'grab';
            } else if (currentTool === 'select') {
                canvas.style.cursor = 'default';
            } else {
                canvas.style.cursor = 'crosshair';
            }

            // Reset polygon drawing when switching tools
            if (currentTool !== 'polygon') {
                isDrawingPolygon = false;
                polygonPoints = [];
                drawExistingAnnotations();
            }
        });
    });

    // Label category selection
    document.querySelectorAll('.label-category').forEach(cat => {
        cat.addEventListener('click', function() {
            // Remove selection from all categories
            document.querySelectorAll('.label-category').forEach(c => c.classList.remove('bg-blue-600'));
            // Add selection to clicked category
            this.classList.add('bg-blue-600');
            // Set selected category
            selectedCategory = parseInt(this.dataset.categoryId);
        });
    });

    // Image thumbnails
    document.querySelectorAll('.image-thumbnail').forEach((thumb, index) => {
        thumb.addEventListener('click', function(e) {
            // Don't load image if delete button was clicked
            if (e.target.closest('.thumbnail-delete-btn')) {
                return;
            }
            loadImage(index);
        });
    });

    // Thumbnail delete buttons
    document.querySelectorAll('.thumbnail-delete-btn').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent thumbnail click
            const imageId = parseInt(this.dataset.imageId);
            const imageName = this.dataset.imageName;
            showThumbnailDeleteConfirmation(imageId, imageName);
        });
    });

    // Image upload
    const imageUpload = document.getElementById('image-upload');
    const uploadButton = document.getElementById('upload-images');

    imageUpload.addEventListener('change', function() {
        const files = this.files;
        if (files.length > 0) {
            uploadButton.disabled = false;
            uploadButton.textContent = `Upload ${files.length} Image${files.length > 1 ? 's' : ''}`;
        } else {
            uploadButton.disabled = true;
            uploadButton.innerHTML = '<i class="fas fa-upload mr-2"></i>Upload Selected Images';
        }
    });

    // Add event listener for YOLO classes import
    const yoloClassesUpload = document.getElementById('yolo-classes-upload');
    yoloClassesUpload.addEventListener('change', handleYOLOClassesUpload);

    uploadButton.addEventListener('click', uploadImages);

    // Canvas events
    const canvas = document.getElementById('annotation-canvas');
    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('contextmenu', function(e) {
        // Show context menu on right-click if annotation is selected
        if (selectedAnnotations.length > 0) {
            e.preventDefault();
            lastContextMenuX = e.clientX;
            lastContextMenuY = e.clientY;
            showAnnotationContextMenu();
            return false;
        }
    });
    canvas.addEventListener('dblclick', function(e) {
        if (currentTool === 'polygon' && isDrawingPolygon) {
            completePolygon();
        }
    });

    // Mouse wheel zoom
    canvas.addEventListener('wheel', function(e) {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = Math.max(0.1, Math.min(5, zoomLevel * zoomFactor));

        // Zoom towards mouse position
        const zoomRatio = newZoom / zoomLevel;
        panX = mouseX - (mouseX - panX) * zoomRatio;
        panY = mouseY - (mouseY - panY) * zoomRatio;
        zoomLevel = newZoom;

        updateImageTransform();
    });

    // Pan functionality
    canvas.addEventListener('mousedown', function(e) {
        // Pan if pan tool is selected, or middle mouse, or Ctrl+left click
        if (currentTool === 'pan' || e.button === 1 || (e.button === 0 && e.ctrlKey)) {
            isPanning = true;
            lastPanX = e.clientX;
            lastPanY = e.clientY;
            canvas.style.cursor = 'grabbing';
            e.preventDefault();
        }
    });

    canvas.addEventListener('mousemove', function(e) {
        if (isPanning) {
            const deltaX = e.clientX - lastPanX;
            const deltaY = e.clientY - lastPanY;
            panX += deltaX;
            panY += deltaY;
            lastPanX = e.clientX;
            lastPanY = e.clientY;
            updateImageTransform();
        }
    });

    canvas.addEventListener('mouseup', function(e) {
        if (isPanning) {
            isPanning = false;
            canvas.style.cursor = 'crosshair';
        }
    });

    canvas.addEventListener('mouseleave', function(e) {
        if (isPanning) {
            isPanning = false;
            canvas.style.cursor = 'crosshair';
        }
    });


    // Close image button
    document.getElementById('close-image').addEventListener('click', closeImage);

    // Delete image button
    document.getElementById('delete-image').addEventListener('click', showDeleteConfirmation);

    // Delete confirmation modal
    document.getElementById('cancel-delete').addEventListener('click', hideDeleteConfirmation);
    document.getElementById('confirm-delete').addEventListener('click', deleteImage);

    // Thumbnail delete confirmation modal
    document.getElementById('cancel-thumbnail-delete').addEventListener('click', hideThumbnailDeleteConfirmation);
    document.getElementById('confirm-thumbnail-delete').addEventListener('click', deleteThumbnailImage);

    // Project name editing
    document.getElementById('edit-project-name').addEventListener('click', startEditingProjectName);
    document.getElementById('project-name-display').addEventListener('click', startEditingProjectName);
    document.getElementById('project-name-input').addEventListener('blur', saveProjectName);
    document.getElementById('project-name-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            saveProjectName();
        } else if (e.key === 'Escape') {
            cancelEditingProjectName();
        }
    });

    // Add category modal
    document.getElementById('add-category').addEventListener('click', () => {
        document.getElementById('add-category-modal').classList.remove('hidden');
        document.getElementById('add-category-modal').classList.add('flex');
    });

    document.getElementById('cancel-category').addEventListener('click', () => {
        document.getElementById('add-category-modal').classList.add('hidden');
        document.getElementById('add-category-modal').classList.remove('flex');
    });

    document.getElementById('category-form').addEventListener('submit', addCategory);

    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
        // Escape key to close current image
        if (e.key === 'Escape') {
            const mainImage = document.getElementById('main-image');
            if (!mainImage.classList.contains('hidden')) {
                closeImage();
            }
        }
        // Delete key to delete selected annotations
        if (e.key === 'Delete' && selectedAnnotations.length > 0) {
            deleteSelectedAnnotations();
        }
        // Enter key to complete polygon
        if (e.key === 'Enter' && currentTool === 'polygon' && isDrawingPolygon) {
            completePolygon();
        }
        // Escape key to cancel polygon
        if (e.key === 'Escape' && currentTool === 'polygon' && isDrawingPolygon) {
            isDrawingPolygon = false;
            polygonPoints = [];
            drawExistingAnnotations();
        }
        // Ctrl+A to select all annotations
        if ((e.ctrlKey || e.metaKey) && e.key === 'a' && currentTool === 'select') {
            e.preventDefault();
            selectAllAnnotations();
            showNotification(`Selected ${selectedAnnotations.length} annotation(s)`, 'success');
        }
        // Ctrl+C to copy selected annotations
        if ((e.ctrlKey || e.metaKey) && e.key === 'c' && selectedAnnotations.length > 0) {
            e.preventDefault();
            copyAnnotations();
        }
        // Ctrl+V to paste annotations
        if ((e.ctrlKey || e.metaKey) && e.key === 'v' && currentTool === 'select') {
            e.preventDefault();
            pasteAnnotations();
        }
    });

    // Context menu event listeners
    document.getElementById('edit-annotation').addEventListener('click', editAnnotation);
    document.getElementById('delete-annotation').addEventListener('click', deleteSelectedAnnotations);

    // Zoom and pan event listeners
    document.getElementById('zoom-in').addEventListener('click', zoomIn);
    document.getElementById('zoom-out').addEventListener('click', zoomOut);
    document.getElementById('fit-to-screen').addEventListener('click', fitToScreen);

    // Hide context menu when clicking elsewhere
    document.addEventListener('click', function(e) {
        if (!e.target.closest('#annotation-context-menu') && !e.target.closest('#annotation-canvas')) {
            hideAnnotationContextMenu();
        }
    });

    // Username handling
    loadUsername();

    document.getElementById('save-username').addEventListener('click', saveUsername);
    document.getElementById('username-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            saveUsername();
        }
    });
}

// Username management
function loadUsername() {
    const username = localStorage.getItem('labeler_username');
    if (username) {
        document.getElementById('username-text').textContent = username;
        document.getElementById('username-display').classList.remove('hidden');
        document.getElementById('username-input-container').classList.add('hidden');
    } else {
        document.getElementById('username-display').classList.add('hidden');
        document.getElementById('username-input-container').classList.remove('hidden');
    }
}

function saveUsername() {
    const usernameInput = document.getElementById('username-input');
    const username = usernameInput.value.trim();

    if (!username) {
        showNotification('Please enter your name', 'error');
        usernameInput.focus();
        return;
    }

    localStorage.setItem('labeler_username', username);
    loadUsername();
    showNotification(`Welcome, ${username}!`, 'success');
}

function getUsername() {
    return localStorage.getItem('labeler_username');
}

function loadImage(index) {
    if (index < 0 || index >= images.length) {
        // No images available, show placeholder
        showNoImagePlaceholder();
        return;
    }

    // Deselect any selected annotations when switching images
    deselectAllAnnotations();

    // Reset polygon drawing when switching images
    isDrawingPolygon = false;
    polygonPoints = [];

    // Reset zoom and pan
    zoomLevel = 1;
    panX = 0;
    panY = 0;

    currentImageIndex = index;
    const image = images[index];

    document.getElementById('loading-overlay').classList.remove('hidden');
    document.getElementById('no-image-placeholder').classList.add('hidden');

    const img = document.getElementById('main-image');

    // Add timeout to prevent infinite loading
    const loadingTimeout = setTimeout(() => {
        document.getElementById('loading-overlay').classList.add('hidden');
        showNotification('Image loading timed out', 'error');
    }, 10000); // 10 second timeout

    // Add error handling for failed image loads
    img.onerror = function() {
        clearTimeout(loadingTimeout);
        document.getElementById('loading-overlay').classList.add('hidden');
        showNotification('Failed to load image', 'error');
        console.error('Failed to load image:', image.file_path);
    };

    img.onload = function() {
        clearTimeout(loadingTimeout);
        document.getElementById('loading-overlay').classList.add('hidden');
        img.classList.remove('hidden');

        // Store image dimensions for bounds checking
        imageWidth = images[index].width;
        imageHeight = images[index].height;

        setupCanvas();

        // Automatically fit image to screen
        fitToScreen();

        // Load annotations after canvas is set up
        setTimeout(() => {
            loadImageAnnotations(image.id);
        }, 100); // Small delay to ensure canvas is ready

        // Enable close and delete buttons when image is loaded
        document.getElementById('close-image').disabled = false;
        document.getElementById('close-image').classList.remove('opacity-50', 'cursor-not-allowed');
        document.getElementById('delete-image').disabled = false;
        document.getElementById('delete-image').classList.remove('opacity-50', 'cursor-not-allowed');
    };

    img.src = `/${image.file_path}`;
    document.getElementById('current-image').textContent = index + 1;

    // Update thumbnail selection
    document.querySelectorAll('.image-thumbnail').forEach((thumb, i) => {
        thumb.classList.toggle('border-blue-500', i === index);
    });
}

function showNoImagePlaceholder() {
    document.getElementById('main-image').classList.add('hidden');
    document.getElementById('no-image-placeholder').classList.remove('hidden');
    document.getElementById('current-image').textContent = '0';

    // Disable close and delete buttons when no image is loaded
    document.getElementById('close-image').disabled = true;
    document.getElementById('close-image').classList.add('opacity-50', 'cursor-not-allowed');
    document.getElementById('delete-image').disabled = true;
    document.getElementById('delete-image').classList.add('opacity-50', 'cursor-not-allowed');
}

function closeImage() {
    // Hide the current image and show the placeholder
    document.getElementById('main-image').classList.add('hidden');
    document.getElementById('no-image-placeholder').classList.remove('hidden');
    document.getElementById('current-image').textContent = '0';

    // Clear the canvas
    const canvas = document.getElementById('annotation-canvas');
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Clear current annotations
    annotations = [];

    // Reset thumbnail selection
    document.querySelectorAll('.image-thumbnail').forEach(thumb => {
        thumb.classList.remove('border-blue-500');
    });

    // Show notification
    showNotification('Image closed', 'info');
}

function showDeleteConfirmation() {
    document.getElementById('delete-image-modal').classList.remove('hidden');
    document.getElementById('delete-image-modal').classList.add('flex');
}

function hideDeleteConfirmation() {
    document.getElementById('delete-image-modal').classList.add('hidden');
    document.getElementById('delete-image-modal').classList.remove('flex');
}

function deleteImage() {
    if (images.length === 0 || currentImageIndex < 0 || currentImageIndex >= images.length) {
        showNotification('No image to delete', 'error');
        return;
    }

    const imageToDelete = images[currentImageIndex];

    // Show loading state
    document.getElementById('confirm-delete').disabled = true;
    document.getElementById('confirm-delete').innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i>Deleting...';

    // Delete the image via API
    fetch(`/api/images/${imageToDelete.id}`, {
        method: 'DELETE'
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        // Remove image from local array
        images.splice(currentImageIndex, 1);

        // Update UI
        updateImageGrid();

        // If we deleted the last image, show placeholder
        if (images.length === 0) {
            showNoImagePlaceholder();
        } else {
            // Adjust current index if needed
            if (currentImageIndex >= images.length) {
                currentImageIndex = images.length - 1;
            }
            // Load the next/previous image
            loadImage(currentImageIndex);
        }

        // Hide modal
        hideDeleteConfirmation();

        // Show success notification
        showNotification('Image deleted successfully', 'success');
    })
    .catch(error => {
        console.error('Error deleting image:', error);
        showNotification('Error deleting image', 'error');

        // Reset button state
        document.getElementById('confirm-delete').disabled = false;
        document.getElementById('confirm-delete').innerHTML = '<i class="fas fa-trash mr-1"></i>Delete Image';
    });
}

function showThumbnailDeleteConfirmation(imageId, imageName) {
    document.getElementById('thumbnail-delete-image-name').textContent = imageName;
    document.getElementById('thumbnail-delete-modal').classList.remove('hidden');
    document.getElementById('thumbnail-delete-modal').classList.add('flex');
}

function hideThumbnailDeleteConfirmation() {
    document.getElementById('thumbnail-delete-modal').classList.add('hidden');
    document.getElementById('thumbnail-delete-modal').classList.remove('flex');
}

function deleteThumbnailImage() {
    // Get the image ID from the modal context
    const imageName = document.getElementById('thumbnail-delete-image-name').textContent;
    const image = images.find(img => img.original_filename === imageName);
    if (!image) {
        showNotification('Image not found', 'error');
        hideThumbnailDeleteConfirmation();
        return;
    }
    const imageId = image.id;

    // Show loading state
    document.getElementById('confirm-thumbnail-delete').disabled = true;
    document.getElementById('confirm-thumbnail-delete').innerHTML = '<i class="fas fa-spinner fa-spin mr-1"></i>Deleting...';

    // Delete the image via API
    fetch(`/api/images/${imageId}`, {
        method: 'DELETE'
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        // Find and remove image from local array
        const imageIndex = images.findIndex(img => img.id === imageId);
        if (imageIndex !== -1) {
            images.splice(imageIndex, 1);
        }

        // Update UI
        updateImageGrid();

        // If we deleted the currently loaded image, show placeholder or load next
        if (currentImageIndex === imageIndex) {
            if (images.length === 0) {
                showNoImagePlaceholder();
            } else {
                // Adjust current index if needed
                if (currentImageIndex >= images.length) {
                    currentImageIndex = images.length - 1;
                }
                // Load the next/previous image
                loadImage(currentImageIndex);
            }
        } else if (imageIndex < currentImageIndex) {
            // Adjust current index if we deleted an image before the current one
            currentImageIndex--;
        }

        // Hide modal
        hideThumbnailDeleteConfirmation();

        // Show success notification
        showNotification('Image deleted successfully', 'success');
    })
    .catch(error => {
        console.error('Error deleting image:', error);
        showNotification('Error deleting image', 'error');

        // Reset button state
        document.getElementById('confirm-thumbnail-delete').disabled = false;
        document.getElementById('confirm-thumbnail-delete').innerHTML = '<i class="fas fa-trash mr-1"></i>Delete Image';
    });
}

function updateImageCounters() {
    const imageCount = document.getElementById('image-count');
    const totalImages = document.getElementById('total-images');
    const currentImage = document.getElementById('current-image');

    // Update counts
    const countText = `${images.length} image${images.length !== 1 ? 's' : ''}`;
    imageCount.textContent = countText;
    totalImages.textContent = images.length;

    // Update current image counter
    if (images.length === 0) {
        currentImage.textContent = '0';
    } else if (currentImageIndex >= 0 && currentImageIndex < images.length) {
        currentImage.textContent = currentImageIndex + 1;
    } else {
        currentImage.textContent = '0';
    }
}

function updateImageGrid() {
    const imageGrid = document.getElementById('image-grid');

    // Update counters
    updateImageCounters();

    // Rebuild grid
    imageGrid.innerHTML = '';
    images.forEach((image, index) => {
        const thumbDiv = document.createElement('div');
        thumbDiv.className = 'image-thumbnail cursor-pointer border-2 border-transparent hover:border-blue-500 rounded-lg overflow-hidden transition-colors relative group';
        thumbDiv.setAttribute('data-image-id', image.id);

        thumbDiv.innerHTML = `
            <img src="/${image.thumbnail_path}"
                 alt="${image.original_filename}"
                 class="w-full h-20 object-cover">
            <div class="p-1 text-xs text-gray-300 truncate">${image.original_filename}</div>
            <!-- Delete button for thumbnail -->
            <button class="thumbnail-delete-btn absolute top-1 right-1 w-6 h-6 bg-red-600 text-white rounded-full opacity-0 group-hover:opacity-100 transition-opacity duration-200 flex items-center justify-center text-xs hover:bg-red-700"
                    data-image-id="${image.id}"
                    data-image-name="${image.original_filename}"
                    title="Delete image">
                <i class="fas fa-times"></i>
            </button>
        `;

        // Add click event for thumbnail
        thumbDiv.addEventListener('click', function(e) {
            // Don't load image if delete button was clicked
            if (e.target.closest('.thumbnail-delete-btn')) {
                return;
            }
            loadImage(index);
        });

        // Add click event for delete button
        const deleteBtn = thumbDiv.querySelector('.thumbnail-delete-btn');
        deleteBtn.addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent thumbnail click
            const imageId = parseInt(this.dataset.imageId);
            const imageName = this.dataset.imageName;
            showThumbnailDeleteConfirmation(imageId, imageName);
        });

        imageGrid.appendChild(thumbDiv);
    });
}

function startEditingProjectName() {
    const display = document.getElementById('project-name-display');
    const input = document.getElementById('project-name-input');
    const editBtn = document.getElementById('edit-project-name');

    // Hide display and show input
    display.classList.add('hidden');
    input.classList.remove('hidden');
    editBtn.classList.add('hidden');

    // Focus and select text
    input.focus();
    input.select();
}

function cancelEditingProjectName() {
    const display = document.getElementById('project-name-display');
    const input = document.getElementById('project-name-input');
    const editBtn = document.getElementById('edit-project-name');

    // Reset input value to original
    input.value = display.textContent;

    // Hide input and show display
    input.classList.add('hidden');
    display.classList.remove('hidden');
    editBtn.classList.remove('hidden');
}

function saveProjectName() {
    const display = document.getElementById('project-name-display');
    const input = document.getElementById('project-name-input');
    const editBtn = document.getElementById('edit-project-name');
    const projectId = input.dataset.projectId;
    const newName = input.value.trim();

    if (!newName) {
        showNotification('Project name cannot be empty', 'error');
        cancelEditingProjectName();
        return;
    }

    if (newName === display.textContent) {
        // No change, just cancel editing
        cancelEditingProjectName();
        return;
    }

    // Show loading state
    input.disabled = true;
    input.value = 'Saving...';

    // Update project name via API
    fetch(`/api/projects/${projectId}`, {
        method: 'PUT',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            name: newName
        })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        // Update display
        display.textContent = newName;

        // Hide input and show display
        input.classList.add('hidden');
        display.classList.remove('hidden');
        editBtn.classList.remove('hidden');

        // Reset input
        input.disabled = false;
        input.value = newName;

        // Show success notification
        showNotification('Project name updated successfully', 'success');
    })
    .catch(error => {
        console.error('Error updating project name:', error);
        showNotification('Error updating project name', 'error');

        // Reset input
        input.disabled = false;
        input.value = display.textContent;
        cancelEditingProjectName();
    });
}

function setupCanvas() {
    const canvas = document.getElementById('annotation-canvas');
    const img = document.getElementById('main-image');
    const canvasContainer = document.getElementById('canvas-container');

    // Only setup canvas if image is visible
    if (img.classList.contains('hidden')) {
        return;
    }

    // Set canvas size to match container
    const containerRect = canvasContainer.getBoundingClientRect();
    canvas.width = containerRect.width;
    canvas.height = containerRect.height;

    // Clear canvas
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Update image transform
    updateImageTransform();
}

function startDrawing(e) {
    // Don't handle drawing if pan tool is selected (panning is handled separately)
    if (currentTool === 'pan') {
        return;
    }

    const canvas = document.getElementById('annotation-canvas');
    const ctx = canvas.getContext('2d');
    const img = document.getElementById('main-image');
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - panX) / zoomLevel;
    const y = (e.clientY - rect.top - panY) / zoomLevel;

    if (currentTool === 'select') {
        // Handle annotation selection
        console.log('Select tool clicked at:', x, y);
        const clickedAnnotation = getAnnotationAtPoint(x, y);
        console.log('Found annotation:', clickedAnnotation);

        if (clickedAnnotation) {
            // Check if already selected
            const isAlreadySelected = selectedAnnotations.some(sel => sel.id === clickedAnnotation.id);

            // Multi-select with Ctrl/Cmd key
            if (e.ctrlKey || e.metaKey) {
                toggleAnnotationSelection(clickedAnnotation);
                // Start dragging with Ctrl+click if already selected
                if (isAlreadySelected && selectedAnnotations.length > 0) {
                    startDraggingAnnotations(x, y);
                }
            } else {
                // Single select - clear all and select one
                // Only start dragging if this was already selected (preserving multi-selection)
                if (isAlreadySelected) {
                    // Keep all current selections and start dragging
                    startDraggingAnnotations(x, y);
                } else {
                    // New selection - replace all with just this one
                    selectedAnnotations = [clickedAnnotation];
                    drawExistingAnnotations();
                    // Show context menu for single selection
                    showAnnotationContextMenu();
                }
            }
        } else {
            // Click on empty area - deselect all unless Ctrl is held
            if (!e.ctrlKey && !e.metaKey) {
                deselectAllAnnotations();
            }
        }
        return;
    }

    if (!selectedCategory) return;

    if (currentTool === 'polygon') {
        // Handle polygon drawing
        if (!isDrawingPolygon) {
            // Start new polygon
            isDrawingPolygon = true;
            polygonPoints = [{ x, y }];
            // Convert to screen coordinates for preview
            const screenX = x * zoomLevel + panX;
            const screenY = y * zoomLevel + panY;
            drawPolygonPreview(ctx, screenX, screenY, screenX, screenY); // Draw the first point immediately
        } else {
            // Check if clicking near the first point to close polygon
            if (polygonPoints.length >= 3) {
                const firstPoint = polygonPoints[0];
                const distance = Math.sqrt((x - firstPoint.x) ** 2 + (y - firstPoint.y) ** 2);
                if (distance <= 15) { // 15 pixel radius to close polygon
                    completePolygon();
                    return;
                }
            }

            // Add point to existing polygon
            polygonPoints.push({ x, y });
            // Convert to screen coordinates for preview
            const screenX = x * zoomLevel + panX;
            const screenY = y * zoomLevel + panY;
            drawPolygonPreview(ctx, screenX, screenY, screenX, screenY);
        }
        return;
    }

    isDrawing = true;
    startX = x;
    startY = y;
}

function draw(e) {
    const canvas = document.getElementById('annotation-canvas');
    const ctx = canvas.getContext('2d');
    const rect = canvas.getBoundingClientRect();
    const currentX = (e.clientX - rect.left - panX) / zoomLevel;
    const currentY = (e.clientY - rect.top - panY) / zoomLevel;

    // Handle annotation dragging
    if (isDraggingAnnotations) {
        dragAnnotations(currentX, currentY);
        return;
    }

    if (!isDrawing || currentTool === 'select') return;

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw existing annotations
    drawExistingAnnotations();

    // Draw current annotation preview in screen coordinates
    const screenStartX = startX * zoomLevel + panX;
    const screenStartY = startY * zoomLevel + panY;
    const screenCurrentX = currentX * zoomLevel + panX;
    const screenCurrentY = currentY * zoomLevel + panY;

    if (currentTool === 'bbox') {
        ctx.strokeStyle = getCategoryColor(selectedCategory);
        ctx.lineWidth = 2;
        ctx.strokeRect(screenStartX, screenStartY, screenCurrentX - screenStartX, screenCurrentY - screenStartY);
    } else if (currentTool === 'point') {
        ctx.fillStyle = getCategoryColor(selectedCategory);
        ctx.beginPath();
        ctx.arc(screenStartX, screenStartY, 5, 0, 2 * Math.PI);
        ctx.fill();
    } else if (currentTool === 'polygon') {
        // Draw polygon preview
        drawPolygonPreview(ctx, screenStartX, screenStartY, screenCurrentX, screenCurrentY);
    }
}

function stopDrawing(e) {
    // Handle annotation drag completion
    if (isDraggingAnnotations) {
        stopDraggingAnnotations();
        return;
    }

    if (!isDrawing || currentTool === 'select') return;

    isDrawing = false;
    const rect = e.target.getBoundingClientRect();
    const endX = (e.clientX - rect.left - panX) / zoomLevel;
    const endY = (e.clientY - rect.top - panY) / zoomLevel;

    // Clamp coordinates to image bounds
    const clampedStart = clampToImageBounds(startX, startY);
    const clampedEnd = clampToImageBounds(endX, endY);

    // Create annotation with clamped coordinates
    const annotation = {
        id: Date.now(),
        image_id: images[currentImageIndex].id,
        label_category_id: selectedCategory,
        tool: currentTool,
        coordinates: {
            startX: clampedStart.x,
            startY: clampedStart.y,
            endX: clampedEnd.x,
            endY: clampedEnd.y
        },
        created_at: new Date().toISOString()
    };

    annotations.push(annotation);
    drawExistingAnnotations();

    // Automatically save the annotation to the database
    saveAnnotationToDatabase(annotation);
}

function drawPolygonPreview(ctx, screenStartX, screenStartY, screenCurrentX, screenCurrentY) {
    // Draw polygon preview
    if (polygonPoints.length > 1) {
        ctx.strokeStyle = getCategoryColor(selectedCategory);
        ctx.lineWidth = 2;
        ctx.beginPath();

        // Convert first point to screen coordinates
        const screenX = polygonPoints[0].x * zoomLevel + panX;
        const screenY = polygonPoints[0].y * zoomLevel + panY;
        ctx.moveTo(screenX, screenY);

        for (let i = 1; i < polygonPoints.length; i++) {
            const screenX = polygonPoints[i].x * zoomLevel + panX;
            const screenY = polygonPoints[i].y * zoomLevel + panY;
            ctx.lineTo(screenX, screenY);
        }

        // Draw line to current mouse position
        ctx.lineTo(screenCurrentX, screenCurrentY);
        ctx.stroke();
    }

    // Always draw the first point, even with just one point
    if (polygonPoints.length >= 1) {
        ctx.fillStyle = getCategoryColor(selectedCategory);
        ctx.beginPath();
        const screenX = polygonPoints[0].x * zoomLevel + panX;
        const screenY = polygonPoints[0].y * zoomLevel + panY;
        ctx.arc(screenX, screenY, 5, 0, 2 * Math.PI);
        ctx.fill();
    }

    // Draw additional points (skip first point since it's already drawn)
    ctx.fillStyle = getCategoryColor(selectedCategory);
    polygonPoints.forEach((point, index) => {
        if (index > 0) { // Skip first point since it's already drawn above
            const screenX = point.x * zoomLevel + panX;
            const screenY = point.y * zoomLevel + panY;
            ctx.beginPath();
            ctx.arc(screenX, screenY, 3, 0, 2 * Math.PI);
            ctx.fill();
        }
    });

    // Draw closing indicator around first point if we have enough points
    if (polygonPoints.length >= 3) {
        const firstPoint = polygonPoints[0];
        const screenX = firstPoint.x * zoomLevel + panX;
        const screenY = firstPoint.y * zoomLevel + panY;
        ctx.strokeStyle = getCategoryColor(selectedCategory);
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]); // Dashed line
        ctx.beginPath();
        ctx.arc(screenX, screenY, 15, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.setLineDash([]); // Reset line dash
    }
}

function completePolygon() {
    if (polygonPoints.length < 3) {
        console.log('Polygon needs at least 3 points');
        return;
    }

    // Clamp all polygon points to image bounds
    const clampedPoints = polygonPoints.map(point =>
        clampToImageBounds(point.x, point.y)
    );

    // Create polygon annotation
    const annotation = {
        id: Date.now(),
        image_id: images[currentImageIndex].id,
        label_category_id: selectedCategory,
        tool: 'polygon',
        coordinates: {
            points: clampedPoints
        },
        created_at: new Date().toISOString()
    };

    annotations.push(annotation);
    drawExistingAnnotations();

    // Automatically save the annotation to the database
    saveAnnotationToDatabase(annotation);

    // Reset polygon drawing
    isDrawingPolygon = false;
    polygonPoints = [];

}

function drawExistingAnnotations() {
    const canvas = document.getElementById('annotation-canvas');
    const ctx = canvas.getContext('2d');

    // Clear the canvas first
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const currentImageId = images[currentImageIndex]?.id;

    annotations.forEach(annotation => {
        if (annotation.image_id !== currentImageId) return;

        const isSelected = selectedAnnotations.some(sel => sel.id === annotation.id);

        // Draw annotation
        ctx.strokeStyle = getCategoryColor(annotation.label_category_id);
        ctx.fillStyle = getCategoryColor(annotation.label_category_id);
        ctx.lineWidth = isSelected ? 3 : 2;

        if (annotation.tool === 'bbox') {
            const { startX, startY, endX, endY } = annotation.coordinates;
            // Convert image coordinates to screen coordinates
            const screenStartX = startX * zoomLevel + panX;
            const screenStartY = startY * zoomLevel + panY;
            const screenEndX = endX * zoomLevel + panX;
            const screenEndY = endY * zoomLevel + panY;

            ctx.strokeRect(screenStartX, screenStartY, screenEndX - screenStartX, screenEndY - screenStartY);

            // Draw selection handles if selected
            if (isSelected) {
                drawSelectionHandles(ctx, screenStartX, screenStartY, screenEndX, screenEndY);
            }
        } else if (annotation.tool === 'point') {
            const { startX, startY } = annotation.coordinates;
            // Convert image coordinates to screen coordinates
            const screenX = startX * zoomLevel + panX;
            const screenY = startY * zoomLevel + panY;

            ctx.beginPath();
            ctx.arc(screenX, screenY, isSelected ? 7 : 5, 0, 2 * Math.PI);
            ctx.fill();

            // Draw selection ring if selected
            if (isSelected) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 10, 0, 2 * Math.PI);
                ctx.stroke();
            }
        } else if (annotation.tool === 'polygon') {
            const { points } = annotation.coordinates;
            if (points && points.length > 2) {
                ctx.beginPath();
                // Convert first point to screen coordinates
                const screenX = points[0].x * zoomLevel + panX;
                const screenY = points[0].y * zoomLevel + panY;
                ctx.moveTo(screenX, screenY);

                for (let i = 1; i < points.length; i++) {
                    const screenX = points[i].x * zoomLevel + panX;
                    const screenY = points[i].y * zoomLevel + panY;
                    ctx.lineTo(screenX, screenY);
                }
                ctx.closePath();
                ctx.stroke();

                // Draw points
                points.forEach(point => {
                    const screenX = point.x * zoomLevel + panX;
                    const screenY = point.y * zoomLevel + panY;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, 3, 0, 2 * Math.PI);
                    ctx.fill();
                });
            }
        }
    });
}

function drawSelectionHandles(ctx, startX, startY, endX, endY) {
    const handleSize = 6;
    const handles = [
        { x: startX, y: startY }, // top-left
        { x: (startX + endX) / 2, y: startY }, // top-center
        { x: endX, y: startY }, // top-right
        { x: endX, y: (startY + endY) / 2 }, // right-center
        { x: endX, y: endY }, // bottom-right
        { x: (startX + endX) / 2, y: endY }, // bottom-center
        { x: startX, y: endY }, // bottom-left
        { x: startX, y: (startY + endY) / 2 } // left-center
    ];

    ctx.fillStyle = '#ffffff';
    ctx.strokeStyle = '#007bff';
    ctx.lineWidth = 2;

    handles.forEach(handle => {
        ctx.fillRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
        ctx.strokeRect(handle.x - handleSize/2, handle.y - handleSize/2, handleSize, handleSize);
    });
}

function getCategoryColor(categoryId) {
    const category = labelCategories.find(cat => cat.id === categoryId);
    return category ? category.color : '#3B82F6';
}

function loadImageAnnotations(imageId) {
    // Load existing annotations for this image
    fetch(`/api/annotations/${imageId}`)
        .then(response => response.json())
        .then(data => {
            console.log('Loading annotations for image', imageId, ':', data.annotations);

            // Convert database annotations to frontend format
            const loadedAnnotations = (data.annotations || []).map(dbAnnotation => {
                // Handle new format where annotation_data is {tool, coordinates}
                let tool, coordinates;

                if (dbAnnotation.annotation_data && dbAnnotation.annotation_data.tool) {
                    // New format: {tool, coordinates}
                    tool = dbAnnotation.annotation_data.tool;
                    coordinates = dbAnnotation.annotation_data.coordinates;
                } else {
                    // Legacy format: annotation_data IS the coordinates, determine tool from structure
                    tool = 'bbox'; // Default
                    if (dbAnnotation.annotation_data && dbAnnotation.annotation_data.points) {
                        tool = 'polygon';
                    } else if (dbAnnotation.annotation_data && dbAnnotation.annotation_data.x !== undefined) {
                        tool = 'point';
                    }
                    coordinates = dbAnnotation.annotation_data;
                }

                console.log('Loaded annotation:', { id: dbAnnotation.id, tool, coordinates });

                return {
                    id: dbAnnotation.id,
                    image_id: dbAnnotation.image_id,
                    label_category_id: dbAnnotation.label_category_id,
                    tool: tool,
                    coordinates: coordinates,
                    created_at: dbAnnotation.created_at
                };
            });

            // Replace annotations for this image
            annotations = annotations.filter(ann => ann.image_id !== imageId);
            annotations = annotations.concat(loadedAnnotations);

            console.log('Total annotations after load:', annotations.length);
            drawExistingAnnotations();
        })
        .catch(error => {
            console.error('Error loading annotations:', error);
        });
}

function saveAnnotationToDatabase(annotation) {
    // Save a single annotation to the database
    let annotationData;

    // Handle different coordinate structures
    if (annotation.tool === 'bbox') {
        annotationData = {
            tool: annotation.tool,
            coordinates: {
                startX: annotation.coordinates.startX,
                startY: annotation.coordinates.startY,
                endX: annotation.coordinates.endX,
                endY: annotation.coordinates.endY
            }
        };
    } else if (annotation.tool === 'point') {
        // Points use startX/startY structure (same as bbox creation)
        annotationData = {
            tool: annotation.tool,
            coordinates: {
                startX: annotation.coordinates.startX,
                startY: annotation.coordinates.startY,
                endX: annotation.coordinates.endX,
                endY: annotation.coordinates.endY
            }
        };
    } else if (annotation.tool === 'polygon') {
        annotationData = {
            tool: annotation.tool,
            coordinates: {
                points: annotation.coordinates.points
            }
        };
    } else {
        // Fallback for pasted annotations that already have the right structure
        annotationData = {
            tool: annotation.tool,
            coordinates: annotation.coordinates
        };
    }

    fetch('/api/annotations', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            image_id: annotation.image_id,
            label_category_id: annotation.label_category_id,
            annotation_data: annotationData,
            confidence: annotation.confidence || 1.0
        })
    })
    .then(response => response.json())
    .then(data => {
        // Update the annotation with the database ID
        annotation.id = data.annotation_id;
        console.log('Annotation saved to database with ID:', data.annotation_id);
    })
    .catch(error => {
        console.error('Error saving annotation:', error);
        showNotification('Error saving annotation', 'error');
    });
}


function uploadImages() {
    const fileInput = document.getElementById('image-upload');
    const files = fileInput.files;

    if (files.length === 0) {
        showNotification('Please select images to upload', 'error');
        return;
    }

    const uploadButton = document.getElementById('upload-images');
    uploadButton.disabled = true;
    uploadButton.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i>Uploading...';

    const formData = new FormData();
    Array.from(files).forEach(file => {
        formData.append('file', file);
    });
    formData.append('dataset_id', {{ dataset.id }});

    fetch('/api/images/upload', {
        method: 'POST',
        body: formData
    })
    .then(response => response.json())
    .then(data => {
        showNotification(`${files.length} image(s) uploaded successfully!`, 'success');
        // Reset upload form
        fileInput.value = '';
        uploadButton.disabled = true;
        uploadButton.innerHTML = '<i class="fas fa-upload mr-2"></i>Upload Selected Images';
        // Reload page to show new images
        setTimeout(() => {
            location.reload();
        }, 1500); // Small delay to show notification
    })
    .catch(error => {
        console.error('Error uploading images:', error);
        showNotification('Error uploading images', 'error');
        uploadButton.disabled = false;
        uploadButton.innerHTML = '<i class="fas fa-upload mr-2"></i>Upload Selected Images';
    });
}

function addCategory(e) {
    e.preventDefault();

    const name = document.getElementById('category-name').value;
    const color = document.getElementById('category-color').value;

    fetch('/api/label-categories', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            name: name,
            color: color,
            project_id: {{ project.id }}
        })
    })
    .then(response => response.json())
    .then(data => {
        showNotification('Category added successfully!', 'success');
        location.reload(); // Refresh to show new category
    })
    .catch(error => {
        console.error('Error adding category:', error);
        showNotification('Error adding category', 'error');
    });
}

function showNotification(message, type = 'info') {
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `fixed top-4 right-4 px-6 py-3 rounded-lg shadow-lg z-50 transition-all duration-300 transform translate-x-full`;

    // Set colors based on type
    if (type === 'success') {
        notification.classList.add('bg-green-500', 'text-white');
    } else if (type === 'error') {
        notification.classList.add('bg-red-500', 'text-white');
    } else {
        notification.classList.add('bg-blue-500', 'text-white');
    }

    notification.innerHTML = `
        <div class="flex items-center">
            <i class="fas fa-${type === 'success' ? 'check' : type === 'error' ? 'exclamation' : 'info'}-circle mr-2"></i>
            <span>${message}</span>
        </div>
    `;

    document.body.appendChild(notification);

    // Animate in
    setTimeout(() => {
        notification.classList.remove('translate-x-full');
    }, 100);

    // Auto remove after 3 seconds
    setTimeout(() => {
        notification.classList.add('translate-x-full');
        setTimeout(() => {
            document.body.removeChild(notification);
        }, 300);
    }, 3000);
}

// Annotation selection and editing functions
function getAnnotationAtPoint(x, y) {
    const currentImageId = images[currentImageIndex]?.id;
    if (!currentImageId) return null;

    const imageAnnotations = annotations.filter(ann => ann.image_id === currentImageId);

    // Check annotations in reverse order (topmost first)
    for (let i = imageAnnotations.length - 1; i >= 0; i--) {
        const annotation = imageAnnotations[i];
        if (isPointInAnnotation(x, y, annotation)) {
            return annotation;
        }
    }
    return null;
}

function isPointInAnnotation(x, y, annotation) {
    if (annotation.tool === 'bbox') {
        const { startX, startY, endX, endY } = annotation.coordinates;
        const minX = Math.min(startX, endX);
        const maxX = Math.max(startX, endX);
        const minY = Math.min(startY, endY);
        const maxY = Math.max(startY, endY);

        return x >= minX && x <= maxX && y >= minY && y <= maxY;
    } else if (annotation.tool === 'point') {
        const { startX, startY } = annotation.coordinates;
        const distance = Math.sqrt((x - startX) ** 2 + (y - startY) ** 2);
        return distance <= 10; // 10 pixel radius for point selection
    } else if (annotation.tool === 'polygon') {
        const { points } = annotation.coordinates;
        if (!points || points.length < 3) return false;

        // Use ray casting algorithm for point-in-polygon test
        let inside = false;
        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
            if ((points[i].y > y) !== (points[j].y > y) &&
                x < (points[j].x - points[i].x) * (y - points[i].y) / (points[j].y - points[i].y) + points[i].x) {
                inside = !inside;
            }
        }
        return inside;
    }
    return false;
}

function selectAnnotation(annotation) {
    // Legacy single-select function (for compatibility)
    selectedAnnotations = [annotation];
    drawExistingAnnotations();
    showAnnotationContextMenu();
}

function deselectAllAnnotations() {
    selectedAnnotations = [];
    drawExistingAnnotations();
    hideAnnotationContextMenu();
}

function toggleAnnotationSelection(annotation) {
    const index = selectedAnnotations.findIndex(sel => sel.id === annotation.id);
    if (index !== -1) {
        // Deselect if already selected
        selectedAnnotations.splice(index, 1);
    } else {
        // Add to selection
        selectedAnnotations.push(annotation);
    }
    drawExistingAnnotations();
}

function selectAllAnnotations() {
    const currentImageId = images[currentImageIndex]?.id;
    selectedAnnotations = annotations.filter(ann => ann.image_id === currentImageId);
    drawExistingAnnotations();
}

// Copy and paste functions
function copyAnnotations() {
    if (selectedAnnotations.length === 0) {
        showNotification('No annotations selected to copy', 'error');
        return;
    }

    // Deep copy the selected annotations and remove IDs (will be regenerated on paste)
    const annotationsToCopy = selectedAnnotations.map(annotation => {
        return {
            label_category_id: annotation.label_category_id,
            tool: annotation.tool,
            coordinates: JSON.parse(JSON.stringify(annotation.coordinates)),
            confidence: annotation.confidence || 0.5,
            image_id: images[currentImageIndex].id // Store the source image ID
        };
    });

    // Store in localStorage
    localStorage.setItem('annotation_clipboard', JSON.stringify(annotationsToCopy));

    showNotification(`Copied ${selectedAnnotations.length} annotation(s)`, 'success');
}

function pasteAnnotations() {
    const clipboardData = localStorage.getItem('annotation_clipboard');
    if (!clipboardData) {
        showNotification('No annotations in clipboard', 'error');
        return;
    }

    try {
        const annotationsToPaste = JSON.parse(clipboardData);
        if (!Array.isArray(annotationsToPaste) || annotationsToPaste.length === 0) {
            showNotification('Clipboard is empty', 'error');
            return;
        }

        const currentImageId = images[currentImageIndex].id;

        // Create new annotations with fresh IDs
        const newAnnotations = annotationsToPaste.map(annotation => {
            const newId = Date.now() + Math.random(); // Generate unique ID
            return {
                id: newId,
                image_id: currentImageId,
                label_category_id: annotation.label_category_id,
                tool: annotation.tool,
                coordinates: annotation.coordinates,
                confidence: annotation.confidence,
                created_at: new Date().toISOString()
            };
        });

        // Add to annotations array
        newAnnotations.forEach(annotation => {
            annotations.push(annotation);
            // Save to database
            saveAnnotationToDatabase(annotation);
        });

        // Select the newly pasted annotations
        selectedAnnotations = newAnnotations;
        drawExistingAnnotations();

        // Ensure selection is visible with a small delay
        setTimeout(() => {
            drawExistingAnnotations();
        }, 50);

        showNotification(`Pasted ${newAnnotations.length} annotation(s)`, 'success');
    } catch (error) {
        console.error('Error pasting annotations:', error);
        showNotification('Error pasting annotations', 'error');
    }
}

// Annotation dragging functions
function startDraggingAnnotations(x, y) {
    if (selectedAnnotations.length === 0) return;

    console.log('Starting drag for', selectedAnnotations.length, 'annotations');
    isDraggingAnnotations = true;
    dragStartX = x;
    dragStartY = y;

    // Store original positions for all selected annotations
    annotationOriginalPositions = selectedAnnotations.map(annotation => {
        const coords = annotation.coordinates;
        return {
            annotation: annotation,
            originalCoords: JSON.parse(JSON.stringify(coords)) // Deep copy
        };
    });

    console.log('Stored original positions for', annotationOriginalPositions.length, 'annotations');

    // Change cursor to indicate dragging
    const canvas = document.getElementById('annotation-canvas');
    canvas.style.cursor = 'grabbing';
}

function dragAnnotations(x, y) {
    if (selectedAnnotations.length === 0) return;

    const deltaX = x - dragStartX;
    const deltaY = y - dragStartY;

    console.log('Dragging', annotationOriginalPositions.length, 'annotations, delta:', deltaX, deltaY);

    // Update all selected annotations based on their original positions
    console.log('Updating', annotationOriginalPositions.length, 'annotations');
    annotationOriginalPositions.forEach(({ annotation, originalCoords }, index) => {
        const coords = annotation.coordinates;
        console.log(`Annotation ${index}: tool=${annotation.tool}, originalCoords=`, originalCoords);

        if (annotation.tool === 'bbox') {
            // For bounding boxes, move both start and end points
            const newStartX = originalCoords.startX + deltaX;
            const newStartY = originalCoords.startY + deltaY;
            const newEndX = originalCoords.endX + deltaX;
            const newEndY = originalCoords.endY + deltaY;

            // Clamp to image bounds
            const clampedStart = clampToImageBounds(newStartX, newStartY);
            const clampedEnd = clampToImageBounds(newEndX, newEndY);

            coords.startX = clampedStart.x;
            coords.startY = clampedStart.y;
            coords.endX = clampedEnd.x;
            coords.endY = clampedEnd.y;
            console.log(`  Updated bbox to:`, coords);
        } else if (annotation.tool === 'point') {
            // For points, use startX/startY (same structure as bbox)
            const newStartX = originalCoords.startX + deltaX;
            const newStartY = originalCoords.startY + deltaY;

            // Clamp to image bounds
            const clamped = clampToImageBounds(newStartX, newStartY);
            coords.startX = clamped.x;
            coords.startY = clamped.y;
            coords.endX = clamped.x;  // Keep end point same as start for point
            coords.endY = clamped.y;
            console.log(`  Updated point to:`, coords);
        } else if (annotation.tool === 'polygon') {
            // For polygons, move all points
            const newPoints = originalCoords.points.map(point => {
                const clamped = clampToImageBounds(point.x + deltaX, point.y + deltaY);
                return { x: clamped.x, y: clamped.y };
            });
            coords.points = newPoints;
        }
    });

    // Redraw to show new positions
    drawExistingAnnotations();
}

function stopDraggingAnnotations() {
    if (!isDraggingAnnotations) return;

    isDraggingAnnotations = false;
    dragStartX = 0;
    dragStartY = 0;

    // Reset cursor
    const canvas = document.getElementById('annotation-canvas');
    canvas.style.cursor = currentTool === 'pan' ? 'grab' : (currentTool === 'select' ? 'default' : 'crosshair');

    // Save all dragged annotations to database
    const promises = selectedAnnotations.map(annotation => {
        // Only save to database if it has a database ID (persisted annotation)
        if (annotation.id && typeof annotation.id === 'number' && annotation.id < 1000000) {
            return fetch(`/api/annotations/${annotation.id}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    annotation_data: {
                        tool: annotation.tool,
                        coordinates: annotation.coordinates
                    },
                    confidence: annotation.confidence || 0.5
                })
            });
        }
        return Promise.resolve();
    });

    Promise.all(promises)
        .then(() => {
            console.log(`${selectedAnnotations.length} annotation(s) moved and saved`);
        })
        .catch(error => {
            console.error('Error saving annotation positions:', error);
            showNotification('Error saving annotation positions', 'error');
        });

    annotationOriginalPositions = [];
}

function showAnnotationContextMenu() {
    const contextMenu = document.getElementById('annotation-context-menu');
    if (contextMenu && selectedAnnotations.length > 0) {
        // Use stored mouse position if available, otherwise calculate from annotation
        let x, y;

        if (lastContextMenuX && lastContextMenuY) {
            // Use right-click position
            x = lastContextMenuX;
            y = lastContextMenuY;
        } else {
            // Fallback to annotation center position
            const canvas = document.getElementById('annotation-canvas');
            const rect = canvas.getBoundingClientRect();
            const coords = selectedAnnotations[0].coordinates;

            if (selectedAnnotations[0].tool === 'bbox') {
                const centerX = (coords.startX + coords.endX) / 2;
                const centerY = (coords.startY + coords.endY) / 2;
                x = rect.left + centerX * zoomLevel + panX;
                y = rect.top + centerY * zoomLevel + panY;
            } else if (selectedAnnotations[0].tool === 'point') {
                x = rect.left + coords.startX * zoomLevel + panX;
                y = rect.top + coords.startY * zoomLevel + panY;
            } else {
                x = rect.left + rect.width / 2;
                y = rect.top + rect.height / 2;
            }
        }

        // Ensure menu stays within viewport
        const menuWidth = 200; // Approximate menu width
        const menuHeight = 100; // Approximate menu height
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        let finalX = x;
        let finalY = y;

        if (x + menuWidth > viewportWidth) {
            finalX = viewportWidth - menuWidth - 10;
        }
        if (y + menuHeight > viewportHeight) {
            finalY = viewportHeight - menuHeight - 10;
        }

        contextMenu.style.left = finalX + 'px';
        contextMenu.style.top = finalY + 'px';
        contextMenu.style.position = 'fixed';
        contextMenu.style.zIndex = '9999';
        contextMenu.classList.remove('hidden');

        console.log('Context menu shown at:', finalX, finalY, 'from position:', x, y);
    }
}

function hideAnnotationContextMenu() {
    const contextMenu = document.getElementById('annotation-context-menu');
    if (contextMenu) {
        contextMenu.classList.add('hidden');
    }
}

function editAnnotation() {
    if (selectedAnnotations.length === 0) return;

    // For now, just show a simple prompt for editing category (only works for single selection)
    if (selectedAnnotations.length > 1) {
        showNotification('Editing multiple annotations is not yet supported', 'error');
        return;
    }

    const annotation = selectedAnnotations[0];
    const newCategoryName = prompt('Edit annotation category:',
        labelCategories.find(cat => cat.id === annotation.label_category_id)?.name || '');

    if (newCategoryName && newCategoryName.trim()) {
        const newCategory = labelCategories.find(cat => cat.name.toLowerCase() === newCategoryName.toLowerCase());
        if (newCategory) {
            annotation.label_category_id = newCategory.id;
            drawExistingAnnotations();
            showNotification('Annotation updated!', 'success');
        } else {
            showNotification('Category not found!', 'error');
        }
    }
}

function deleteSelectedAnnotation() {
    // Legacy function name for compatibility
    deleteSelectedAnnotations();
}

function deleteSelectedAnnotations() {
    if (selectedAnnotations.length === 0) {
        return;
    }

    const count = selectedAnnotations.length;
    const message = count === 1
        ? 'Are you sure you want to delete this annotation?'
        : `Are you sure you want to delete ${count} annotations?`;

    if (confirm(message)) {
        const promises = [];

        selectedAnnotations.forEach(annotation => {
            // Remove from local array
            const index = annotations.findIndex(ann => ann.id === annotation.id);
            if (index !== -1) {
                annotations.splice(index, 1);
            }

            // Delete from database if it has a database ID (small numbers are database IDs, large numbers are temporary IDs)
            if (annotation.id && typeof annotation.id === 'number' && annotation.id < 1000000) {
                promises.push(
                    fetch(`/api/annotations/${annotation.id}`, {
                        method: 'DELETE'
                    })
                );
            }
        });

        // Wait for all deletions to complete
        Promise.all(promises)
            .then(() => {
                showNotification(`${count} annotation(s) deleted!`, 'success');
            })
            .catch(error => {
                console.error('Error deleting annotations from database:', error);
                showNotification('Error deleting annotations', 'error');
            });

        // Clear selection and redraw
        deselectAllAnnotations();
        drawExistingAnnotations();
    }
}

function exportToYOLO() {
    fetch('/api/export/yolo')
        .then(response => response.blob())
        .then(blob => {
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'yolo_export.zip';
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
            showNotification('YOLO export downloaded successfully!', 'success');
        })
        .catch(error => {
            console.error('Error exporting to YOLO:', error);
            showNotification('Error exporting to YOLO format', 'error');
        });
}

function importYOLOClasses() {
    const fileInput = document.getElementById('yolo-classes-upload');
    fileInput.click();
}

function handleYOLOClassesUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    if (!file.name.endsWith('.txt')) {
        showNotification('Please select a .txt file', 'error');
        return;
    }

    const formData = new FormData();
    formData.append('file', file);
    formData.append('project_id', currentProjectId || 1); // Default to project 1 if not set

    showNotification('Importing YOLO classes...', 'info');

    fetch('/api/import/yolo-classes', {
        method: 'POST',
        body: formData
    })
    .then(response => {
        if (response.ok) {
            return response.json();
        } else {
            return response.json().then(data => {
                throw new Error(data.detail || 'Error importing classes');
            });
        }
    })
    .then(data => {
        showNotification(data.message, 'success');
        // Refresh the categories list
        loadCategories();
    })
    .catch(error => {
        console.error('Error importing YOLO classes:', error);
        showNotification('Error importing YOLO classes', 'error');
    });
}

function clearAllAnnotations() {
    const currentImageId = images[currentImageIndex]?.id;
    if (!currentImageId) {
        showNotification('No image loaded', 'error');
        return;
    }

    if (confirm('Are you sure you want to clear all annotations for this image?')) {
        // Get all annotations for the current image
        const imageAnnotations = annotations.filter(ann => ann.image_id === currentImageId);

        if (imageAnnotations.length === 0) {
            showNotification('No annotations to clear', 'info');
            return;
        }

        // Delete each annotation from the database
        const deletePromises = imageAnnotations.map(annotation => {
            if (annotation.id && typeof annotation.id === 'number' && annotation.id < 1000000) {
                return fetch(`/api/annotations/${annotation.id}`, {
                    method: 'DELETE'
                });
            }
            return Promise.resolve();
        });

        Promise.all(deletePromises)
            .then(() => {
                // Remove all annotations for this image from local array
                annotations = annotations.filter(ann => ann.image_id !== currentImageId);

                // Clear the canvas
                const canvas = document.getElementById('annotation-canvas');
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Deselect any selected annotation
                deselectAllAnnotations();

                showNotification(`Cleared ${imageAnnotations.length} annotation(s)`, 'success');
            })
            .catch(error => {
                console.error('Error clearing annotations:', error);
                showNotification('Error clearing annotations', 'error');
            });
    }
}

// Zoom and pan functions
function zoomIn() {
    zoomLevel = Math.min(5, zoomLevel * 1.2);
    updateImageTransform();
}

function zoomOut() {
    zoomLevel = Math.max(0.1, zoomLevel / 1.2);
    updateImageTransform();
}

function fitToScreen() {
    const canvas = document.getElementById('annotation-canvas');
    const img = document.getElementById('main-image');
    const canvasContainer = document.getElementById('canvas-container');

    // Log function entry
    logDebug('fitToScreen', 'Function called');

    if (!img || img.classList.contains('hidden')) {
        logDebug('fitToScreen', 'No image loaded or image is hidden');
        return;
    }

    // Wait for image to be fully loaded
    if (!img.complete || img.naturalWidth === 0) {
        logDebug('fitToScreen', 'Image not fully loaded, waiting...');
        img.onload = () => fitToScreen();
        return;
    }

    // Get the visible canvas container dimensions
    const containerRect = canvasContainer.getBoundingClientRect();
    const containerWidth = containerRect.width;
    const containerHeight = containerRect.height;

    const imgWidth = img.naturalWidth;
    const imgHeight = img.naturalHeight;

    logDebug('fitToScreen', `Container dimensions: ${containerWidth}x${containerHeight}`);
    logDebug('fitToScreen', `Image dimensions: ${imgWidth}x${imgHeight}`);

    if (imgWidth && imgHeight) {
        // Calculate scale to fit the container with padding
        const scaleX = containerWidth / imgWidth;
        const scaleY = containerHeight / imgHeight;
        zoomLevel = Math.min(scaleX, scaleY) * 0.9; // 0.9 for some padding

        logDebug('fitToScreen', `Scale factors - X: ${scaleX}, Y: ${scaleY}`);
        logDebug('fitToScreen', `Calculated zoom level: ${zoomLevel}`);

        // Center the image in the canvas container
        const scaledWidth = imgWidth * zoomLevel;
        const scaledHeight = imgHeight * zoomLevel;
        panX = (containerWidth - scaledWidth) / 2;
        panY = (containerHeight - scaledHeight) / 2;

        logDebug('fitToScreen', `Scaled dimensions: ${scaledWidth}x${scaledHeight}`);
        logDebug('fitToScreen', `Calculated pan: X=${panX}, Y=${panY}`);

        updateImageTransform();
        logDebug('fitToScreen', 'Transform applied successfully');
    } else {
        logError('fitToScreen', `Invalid image dimensions: ${imgWidth}x${imgHeight}`);
    }
}

function updateImageTransform() {
    const img = document.getElementById('main-image');
    const canvas = document.getElementById('annotation-canvas');
    const canvasContainer = document.getElementById('canvas-container');

    if (!img) return;

    // Update canvas size to match container
    const containerRect = canvasContainer.getBoundingClientRect();
    canvas.width = containerRect.width;
    canvas.height = containerRect.height;

    logDebug('updateImageTransform', `zoomLevel: ${zoomLevel}, panX: ${panX}, panY: ${panY}`);

    // Set image size and position using transforms
    // Ensure the image maintains its natural aspect ratio
    img.style.width = `${img.naturalWidth}px`;
    img.style.height = `${img.naturalHeight}px`;
    img.style.maxWidth = 'none';
    img.style.maxHeight = 'none';
    img.style.objectFit = 'none'; // Prevent any object-fit scaling
    img.style.left = '0px';
    img.style.top = '0px';
    img.style.position = 'absolute';
    img.style.transform = `translate(${panX}px, ${panY}px) scale(${zoomLevel})`;
    img.style.transformOrigin = '0 0';

    logDebug('updateImageTransform', `Applied transform: ${img.style.transform}`);

    // Redraw annotations
    drawExistingAnnotations();
}

// Logging functions
function logDebug(functionName, message) {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] DEBUG [${functionName}]: ${message}`);
}

function logError(functionName, message) {
    const timestamp = new Date().toISOString();
    console.error(`[${timestamp}] ERROR [${functionName}]: ${message}`);
}

function logInfo(functionName, message) {
    const timestamp = new Date().toISOString();
    console.info(`[${timestamp}] INFO [${functionName}]: ${message}`);
}
</script>
{% endblock %}
